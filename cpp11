#define _CRT_SECURE_NO_WARNINGS // Чтобы не ругался на strcpy
#include <iostream>
#include <windows.h>
#include <string>
#include <ctime>

#define MAX_LOGS 1000
#define MAX_TEXT 128

using namespace std;

struct LogRecord {
    DWORD threadId;
    int priority;
    DWORD tick;
    char message[MAX_TEXT];
};

struct LogBuffer {
    LogRecord records[MAX_LOGS];
    LONG index = 0; // Начинаем с 0
};

LogBuffer globalBuffer;          // Общий буфер для всех потоков
CRITICAL_SECTION criticalSection; // Объект синхронизации
bool isRunning = true;            // Флаг для работы циклов

const string arrayText[3] = { "Сообщение: Ошибка", "Сообщение: Предупреждение", "Сообщение: Информация" };

DWORD WINAPI Logger(LPVOID lpParam) {
    srand(GetCurrentThreadId());

    while (isRunning) {
        string text = arrayText[rand() % 3];
        HANDLE thread = GetCurrentThread();

        EnterCriticalSection(&criticalSection);

        if (globalBuffer.index < MAX_LOGS) {
            int id = globalBuffer.index;

            globalBuffer.records[id].threadId = GetCurrentThreadId();
            globalBuffer.records[id].priority = GetThreadPriority(thread);
            globalBuffer.records[id].tick = GetTickCount();

            // Копируем текст в массив char
            strcpy(globalBuffer.records[id].message, text.c_str());

            globalBuffer.index++; 
        }

        LeaveCriticalSection(&criticalSection);


        Sleep(10 + rand() % 91);
    }
    return 0;
}

DWORD WINAPI Checker(LPVOID lpParam) {
    while (isRunning) {
        Sleep(100);

        EnterCriticalSection(&criticalSection);

        system("cls");
        cout << "=== ЖУРНАЛ СОБЫТИЙ ===" << endl;
        cout << "Всего записей: " << globalBuffer.index << endl << endl;

        int current = globalBuffer.index;
        int start = current - 5;
        if (start < 0) start = 0;

        for (int i = start; i < current; i++) {
            LogRecord lr = globalBuffer.records[i];
            cout << "[" << lr.tick << " ms] ";
            cout << "ID: " << lr.threadId << " | ";
            cout << "PRIO: " << lr.priority << " | ";
            cout << lr.message << endl;
        }

        LeaveCriticalSection(&criticalSection);
    }
    return 0;
}

int main()
{
    setlocale(LC_ALL, "Russian");
    InitializeCriticalSection(&criticalSection);

    HANDLE hThreads[4];
    DWORD idThread[4];

    hThreads[0] = CreateThread(NULL, 0, Logger, NULL, 0, &idThread[0]);
    SetThreadPriority(hThreads[0], THREAD_PRIORITY_HIGHEST);

    hThreads[1] = CreateThread(NULL, 0, Logger, NULL, 0, &idThread[1]);
    SetThreadPriority(hThreads[1], THREAD_PRIORITY_NORMAL);

    hThreads[2] = CreateThread(NULL, 0, Logger, NULL, 0, &idThread[2]);
    SetThreadPriority(hThreads[2], THREAD_PRIORITY_BELOW_NORMAL);

    hThreads[3] = CreateThread(NULL, 0, Checker, NULL, 0, &idThread[3]);
    SetThreadPriority(hThreads[3], THREAD_PRIORITY_LOWEST);

    cout << "Программа работает 5 секунд..." << endl;
    Sleep(5000); // Даем потокам поработать 5 секунд

    isRunning = false; // Сообщаем потокам, что пора выходить
    WaitForMultipleObjects(4, hThreads, TRUE, INFINITE); // Ждем пока все закончат

    DeleteCriticalSection(&criticalSection);
    for (int i = 0; i < 4; i++) CloseHandle(hThreads[i]);

    cout << "Работа завершена." << endl;
    return 0;
}
